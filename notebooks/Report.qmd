---
title: "UEFA Champions League Simulation"
output: html_notebook
execute:
  cache: false
  freeze: false
editor_options: 
  chunk_output_type: inline
references:
- id: poisson
  author:
    - family: Heuer
      given: A.
    - literal: et al.
  title: "Soccer: Is scoring goals a predictable Poissonian process?"
  journal: "Eur. Phys."
  volume: 89
  number: 3
  type: journal
  issued:
    month: 2
    year: 2010
  url: "https://iopscience.iop.org/article/10.1209/0295-5075/89/38007/pdf"
---

```{r echo=FALSE}
set.seed(439)
RNGkind("Mersenne-Twister", "Inversion", "Rejection")  # Explicit RNG type

require(devtools, quietly = TRUE)
require(tidyverse, quietly = TRUE)
require(reactable)
require(htmltools)
# devtools::install_github("hturner/BradleyTerry2")
require(BradleyTerry2, quietly = TRUE)
devtools::install_github("hrbrmstr/hrbrthemes", quiet = TRUE)
require(hrbrthemes, quietly = TRUE)
```

## Data Overview

The following data was gathered using the `worldfootballR` library to scrape 2019-20 UEFA Champions League group stage and knockout game results and the 2018-19 domestic league results for the 32 competing teams across 16 individual league competitions[^1] from [fbref.com](https://www.fbref.com).

[^1]: Members from the following domestic leagues took part in the 2019-20 UEFA Champions League group stage: \*Austrian Football Bundesliga, Belgian Pro League, Croatian Football League, Czech First League, English Premier League, French Ligue 1, German Fusball Bundesliga, Greek Super League, Italian Serie A, Dutch Eredivise, Portugese Premeira Liga, Russian Premier League, Serbian SuperLiga, Spanish La Liga, Turkish Super Lig, Ukrainian Premier League\*

```{r echo=FALSE, include=FALSE}
## Read in all league results

austria = readr::read_csv('../data/raw/Austria_Austrian_Football_Bundesliga_2018-19.csv', show_col_types = FALSE)

belgium = readr::read_csv('../data/raw/Belgium_Belgian_Pro_League_2018-19.csv', show_col_types = FALSE)

croatia = readr::read_csv('../data/raw/Croatia_Croatian_Football_League_2018-19.csv', show_col_types = FALSE)

czech = readr::read_csv('../data/raw/Czechia_Czech_First_League_2018-19.csv', show_col_types = FALSE)

england = readr::read_csv('../data/raw/England_Premier_League_2018-19.csv', show_col_types = FALSE)

france = readr::read_csv('../data/raw/France_Ligue_1_2018-19.csv', show_col_types = FALSE)

germany = readr::read_csv('../data/raw/Germany_Fusball_Bundesliga_2018-19.csv', show_col_types = FALSE)

greece = readr::read_csv('../data/raw/Greece_Super_League_Greece_2018-19.csv', show_col_types = FALSE)

italy = readr::read_csv('../data/raw/Italy_Serie_A_2018-19.csv', show_col_types = FALSE)

nether = readr::read_csv('../data/raw/Netherlands_Eredivise_2018-19.csv', show_col_types = FALSE)

portugal = readr::read_csv('../data/raw/Portugal_Premeira_Liga_2018-19.csv', show_col_types = FALSE)

russia = readr::read_csv('../data/raw/Russia_Russian_Premier_League_2018-19.csv', show_col_types = FALSE)

serbia = readr::read_csv('../data/raw/Serbia_Serbian_SuperLiga_2018-19.csv', show_col_types = FALSE)

spain = readr::read_csv('../data/raw/Spain_La_Liga_2018-19.csv', show_col_types = FALSE)

turkey = readr::read_csv('../data/raw/Turkiye_Super_Lig_2018-19.csv', show_col_types = FALSE)

ukraine = readr::read_csv('../data/raw/Ukraine_Ukrainian_Premier_League_2018-19.csv', show_col_types = FALSE)
```

## Data Pre-processing

In order to use the domestic competition and UEFA Champions League matchup data scraped from [fbref.com](https://www.fbref.com/)[^2] with the Bradley-Terry package, `BradleyTerry2`, the raw data must first be cleaned, parsed, and reformated into the package's expected format. This code follows that found in Lecture 12, particularly when refactoring home and away win data into a trainable DataFrame.

[^2]: Specific links and FBRef pages used can be found in the \*GettingRawMatchupData.Rmd\* notebook.

```{r include=FALSE}
# Helper to remove xG columns from relevant leagues so all competitions have the same number of columns

remove_xg = function(df){ 
  if((df %>% select(contains('_xG')) %>% length()) > 0){
    return(df %>% select(-contains('_xG')))
  }
  else {
    return(df)
  }
}

austria = remove_xg(austria)

belgium = remove_xg(belgium)

croatia = remove_xg(croatia)

czech = remove_xg(czech)

england = remove_xg(england)

france = remove_xg(france)

germany = remove_xg(germany)

greece = remove_xg(greece)

italy = remove_xg(italy)

nether = remove_xg(nether)

portugal = remove_xg(portugal)

russia = remove_xg(russia)

serbia = remove_xg(serbia)

spain = remove_xg(spain)

turkey = remove_xg(turkey)

ukraine = remove_xg(ukraine)

# Concatenate all leagues together

all = austria %>%

  rbind(belgium) %>%

  rbind(croatia) %>%

  rbind(czech) %>%

  rbind(england) %>%

  rbind(france) %>%

  rbind(germany) %>%

  rbind(greece) %>%

  rbind(italy) %>%

  rbind(nether) %>%

  rbind(portugal) %>%

  rbind(russia) %>%

  rbind(serbia) %>%

  rbind(spain) %>%

  rbind(turkey) %>%

  rbind(ukraine)

all %>% head(10)
```

With the leagues all concatenated together, we can check to see the distribution of the complete DataFrame's members.

```{r, echo=FALSE}
set.seed(439)
all[sample(1:nrow(all), size=10),]
```

```{r, echo = FALSE}
matches_by_country = all %>%

                        group_by(Country) %>%

                        count(.drop = TRUE)

plot = ggplot2::ggplot(matches_by_country, aes(matches_by_country$Country, matches_by_country$n)) + 

  ggplot2::geom_col() + 

  labs(title = "2018-19 Domestic League Matches By Competing Nation", x = "UEFA Country", y = "Number of Matches") + 

  hrbrthemes::theme_ipsum(grid="Y")

plot
```

```{r}
# CODE FROM LECTURE 12

# results <-

#  no_ties |>

#  dplyr::rename(home.team = Home, away.team = Opponent) |>

#  dplyr::group_by(home.team, away.team) |>

#  dplyr::summarise(

#    home.win = sum(Home_Winner),

#    away.win = sum(Opp_Winner), .groups = 'drop') |>

#  dplyr::mutate(

#    home.team = factor(home.team, levels = unik_teams),

#    away.team = factor(away.team,levels = unik_teams))

no_ties = all %>% filter(HomeGoals != AwayGoals) %>%

  filter(!str_detect(Round, "play-offs") | is.na(Round)) %>% ## removing matchups in pro/rel playoffs, otherwise we'll see skewed strengths for those leagues

  mutate(Home_Winner = case_when(HomeGoals > AwayGoals ~ 1, .default=0),

         Opp_Winner = case_when(AwayGoals > HomeGoals ~ 1, .default=0))

unik_teams = sort(unique(c(no_ties$Home, no_ties$Away)))

results = no_ties %>% 

  rename(home.team = Home, away.team = Away) %>%

  group_by(home.team, away.team) %>%

  dplyr::summarise(

    home.win = sum(Home_Winner),

    away.win = sum(Opp_Winner), .groups = 'drop') |>

  dplyr::mutate(

    home.team = factor(home.team, levels = unik_teams),

    away.team = factor(away.team, levels = unik_teams))

results[sample(1:nrow(results),size=10),]
```

With the data now in place and formatted for `BradleyTerry2`, we can begin fitting a Bradley-Terry model to determine latent team strength for all clubs competing in the 2019-20 UEFA Champions League group stage based on their domestic league results.

## Fitting Bradley-Terry Model Based on Domestic League Results

For this problem, we'll use a weak baseline as a reference, which we found to best fit the team strengths without many missing values, due to disconnected graphs.

Throughout our trials, we found that the Russian team Yenisey, which placed 16th out of 16 teams in the Russian Premier League throughout the 2018-19 season, resulted in a well-defined range of team strengths.[^3]

[^3]: <https://en.wikipedia.org/wiki/2018%E2%80%9319_Russian_Premier_League#League_table>

```{r}
fit <-
  BradleyTerry2::BTm(
    outcome = cbind(home.win, away.win),
    player1 = home.team, player2 = away.team,
    refcat = "Yenisey",
    data = results)
summary(fit)
```

```{r}
lambda_hat = as.data.frame(BradleyTerry2::BTabilities(fit))
lambda_hat = lambda_hat %>% drop_na() %>% arrange(desc(ability))
lambda_hat = rownames_to_column(lambda_hat) %>% rename(team = rowname)
lambda_hat
```

Given the summary of the Bradley-Terry model and its resulting team strengths, it seems that the results were relatively sensitive to positive results for teams in skewed competitions. In other words, in leagues that are typically dominated by a small number of teams (Greece, Czechia), results over and by the top teams in the competitions were "rewarded" more than their counterparts in other "fairer" competitions (England, Spain). Subjectively, clubs like Red Star typically dominant their domestic competition, which means we would expect a high "ability" assignment, like we see in this model.

For the sake of our project, we'll only focus on the strengths of the clubs competing in the 2019-20 UEFA Champions League group stages. From this, we see the aforementioned Red Star leading in "domestic strength", along with other dominant teams from smaller nations, like Olympiacos from Greece and Dinamo Zagreb from Croatia. This aligns with our prior assumptions.

```{r, echo=FALSE}
uefa = read_csv('../data/raw/UEFA_Champions_League_2020_Results_RAW.csv', show_col_types=FALSE) 

uefa = uefa %>% select(Home) %>% mutate(Country = str_extract(uefa$Home, " [a-z]{2,3}$"), Home = str_remove(uefa$Home, " [a-z]{2,3}$")) %>% select(Home, Country, everything())

champs_w_league_ratings = uefa %>% left_join(lambda_hat %>% rename(Home = team)) %>% unique() %>% replace(is.na(.), 0)

champs_w_league_ratings %>% arrange(desc(ability))
```

```{r, echo=FALSE}
strongest = champs_w_league_ratings %>% arrange(desc(ability)) %>% head(5)

plot = ggplot2::ggplot(strongest, aes(Home, ability)) + 

  ggplot2::geom_col() + 

  labs(title = "Top 5 Teams by 2018-19 Domestic Performance Strength", x = "Club", y = "Team Strength λ") + 

  hrbrthemes::theme_ipsum(grid="Y")

plot
```

```{css ref.label="styles", echo=FALSE}
```

```{r ref.label="font_styles", echo=FALSE}
```

```{r echo=FALSE}
champs = read_csv('../data/raw/UEFA_Champions_League_2020_Results_RAW.csv', show_col_types = FALSE)
domestic_strength = read_csv('../data/ratings/UEFA_Champions_League_Domestic_Strengths.csv', show_col_types = FALSE)
```

## Fitting Bradley-Terry with Domestic Strength Covariate

Now, we'll begin by normalizing our derived domestic strengths for each team so that our model can better fit coefficients to the data, and prepare a data frame such that our Bradley-Terry model can be fit using these domestic strengths. Ideally, we'll use these strengths to define the probability, $$
\mathbb{P}(\text{team i with domestic strength x beats team j with domestic strength y}) = \frac{1}{1+e^{-1\times(((\lambda_i+x\lambda_0))-(\lambda_j+y\lambda_0))}}
$$

```{r}
# Normalize strengths
domestic_strength$ability = (domestic_strength$ability-mean(domestic_strength$ability))/sqrt(var(domestic_strength$ability))
domestic_strength
```

```{r, echo=FALSE}
no_ties = champs %>%
  select(-c('Competition_Name','Gender','Country', 'Season_End_Year', 'Wk', 'Date', 'Day','Time', 'Home_xG', 'Away_xG', 'Attendance', 'Referee', 'Notes','Venue', 'MatchURL')) %>%
  filter(HomeGoals != AwayGoals & Round == 'Group stage') %>%
  select(-c('Round')) %>%
  mutate(Home = str_replace(Home, ' [a-z]{2,3}$', ''),
         Away = str_replace(Away, '^[a-z]{2,3} ', ''),
         Home_Winner = case_when(HomeGoals > AwayGoals ~ 1, .default=0),
         Opp_Winner = case_when(AwayGoals > HomeGoals ~ 1, .default=0))

unik_teams = sort(unique(c(no_ties$Home, no_ties$Away)))
results = no_ties %>% 
  left_join(domestic_strength%>% select(Home, ability), relationship='many-to-many') %>%
  rename(home.domestic = ability) %>%
  left_join(domestic_strength %>% rename(Away = Home) %>% select(Away, ability), relationship='many-to-many') %>% rename(away.domestic = ability) %>%
  rename(home.team = Home, away.team = Away) %>%
    group_by(home.team, away.team) %>%
    dplyr::summarise(
        home.win = sum(Home_Winner),
        away.win = sum(Opp_Winner),
        home.domestic = mean(home.domestic),
        away.domestic = mean(away.domestic), .groups = 'drop') |>
    dplyr::mutate(
        home.team = factor(home.team, levels = unik_teams),
        away.team = factor(away.team, levels = unik_teams))

tmp = data.frame(home.win = results$home.win, away.win = results$away.win)
tmp$home.team = data.frame(
  team = results$home.team,
  domestic.strength = scale(results$home.domestic, center = TRUE, scale = TRUE)[,1]
)
tmp$away.team = data.frame(
  team = results$away.team,
  domestic.strength = scale(results$away.domestic, center = TRUE, scale = TRUE)[,1]
)
```

With our strengths now together, we'll do an initial fit of the Bradley-Terry model, and use the coefficient of `domestic.strength` for $\lambda_0$.
```{r}
suppressWarnings({
  fit <-
  BradleyTerry2::BTm(
    outcome = cbind(home.win, away.win),
    player1 = home.team, player2 = away.team,
    formula = ~ team + domestic.strength,
    refcat = "Dinamo Zagreb",
    id = "team",
    separate.ability = TRUE,
    data = tmp)
})
coef(fit)
```

Above, we see a significant issue: team strengths with the value `NA`. This likely arises due to the "disconnected" nature of the group stage data, or the nature that teams do not play other teams outside of their group. Therefore, to determine a strength for each team, we'll take a sample of reference teams, fit the Bradley-Terry model to each, and take the mean of each team's strength. 
```{r}
run_mult_fits = function(num_fits, with_replacement = FALSE, full=FALSE){
  set.seed(439)
  champs = read_csv('../data/raw/UEFA_Champions_League_2020_Results_RAW.csv', show_col_types=FALSE)
  no_ties = champs %>%
    select(-c('Competition_Name','Gender','Country', 'Season_End_Year', 'Wk', 'Date', 'Day','Time', 'Home_xG', 'Away_xG', 'Attendance', 'Referee', 'Notes','Venue', 'MatchURL')) %>%
    filter(HomeGoals != AwayGoals & Round == 'Group stage') %>%
    select(-c('Round')) %>%
    mutate(Home = str_replace(Home, ' [a-z]{2,3}$', ''),
           Away = str_replace(Away, '^[a-z]{2,3} ', ''),
           Home_Winner = case_when(HomeGoals > AwayGoals ~ 1, .default=0),
           Opp_Winner = case_when(AwayGoals > HomeGoals ~ 1, .default=0))
  unik_teams = sort(unique(c(no_ties$Home, no_ties$Away)))
  suppressWarnings({
    fit <-
    BradleyTerry2::BTm(
      outcome = cbind(home.win, away.win),
      player1 = home.team, player2 = away.team,
      formula = ~ team + domestic.strength,
      refcat = 'Ajax',
      id = "team",
      separate.ability = TRUE,
      data = tmp)
  })
  coefs = transpose(data.table(unik_teams))
  colnames(coefs) = coef(fit) %>% names
  coefs[1,] = 0
  for(i in 2:num_fits){
    zero_row = transpose(data.table(rep(0,length(colnames(coefs)))))
    colnames(zero_row) = coef(fit) %>% names
    coefs = coefs %>% rbind(zero_row)
  }
  coefs$Ref = sample(unik_teams,size=num_fits,replace=with_replacement)
  
  c = transpose(data.frame(coef(fit)))
  colnames(c) = coef(fit) %>% names
  coefs = coefs %>% select(c(colnames(c), str_c(),'Ref')) %>% select(-c('domestic.strength'))
  ref_cat = str_c('team',coefs[1,] %>% pull(Ref))
  c[1,'Ref'] = coefs[1,] %>% pull(Ref)
  coefs[1,] = c[1,] %>% select(-c('domestic.strength'))
  coefs[1,ref_cat] = 0
  coefs = coefs %>% select(sort(colnames(coefs)))
  
  for(i in 2:num_fits){
    suppressWarnings({
      fit <-
      BradleyTerry2::BTm(
        outcome = cbind(home.win, away.win),
        player1 = home.team, player2 = away.team,
        formula = ~ team + domestic.strength,
        refcat = coefs[i,] %>% pull(Ref),
        id = "team",
        separate.ability = TRUE,
        data = tmp)
    })
    c = transpose(data.frame(coef(fit)))
    colnames(c) = coef(fit) %>% names
    ref_cat = str_c('team',coefs[i,] %>% pull(Ref))
    c[1,'Ref'] = coefs[i,] %>% pull(Ref)
    c = c %>% select(-c('domestic.strength'))
    c[1,ref_cat] = 0
    c = c %>% select(colnames(coefs))
    coefs[i,] = c[1,]
  }
  
  coefs[is.na(coefs)] = 0
  teams = coefs %>% select(-c('Ref')) %>% names
  adjusted_coefs = c()
  for(i in 1:length(teams)){
    team = as.numeric(coefs %>% pull(teams[i]))
    team = team[team != 0]
    adjusted_coef = sum(team)/length(team)
    adjusted_coefs[length(adjusted_coefs) + 1] = adjusted_coef
  }
  adjusted = tibble(team = teams %>% str_replace('team', ''), ability = adjusted_coefs)
  if(full){
    return(list(coefs, adjusted))
  }
  return(adjusted)
}
```

```{r}
lambda0_hat = -5.26800595 # from initial fit
lambda_hat = run_mult_fits(100, with_replacement=TRUE)
sd_ability = sd(c(lambda_hat$ability, lambda0_hat))
mu_ability = mean(c(lambda_hat$ability, lambda0_hat))

## normalizing results
lambda0_hat = (-5.26800595-mu_ability)/sd_ability
lambda_hat$ability = (lambda_hat$ability-mu_ability)/sd_ability

uefa_playoff_teams= c(
  "Atalanta", "RB Leipzig", "Barcelona", "Manchester City",
  "Lyon", "Paris S-G", "Atlético Madrid", "Bayern Munich"
)
uefa_playoff_team_strengths = lambda_hat[lambda_hat$team %in% uefa_playoff_teams,] %>% column_to_rownames('team')
uefa_playoff_team_strengths %>% arrange(desc(ability))
```

With our team strengths in place, we can now begin computing the probabilities for each potential match-up that occurs in the quarter final through the final round, based on the formula described above.

```{r, echo=FALSE}
suppressMessages({
  possible_matchups =
    expand.grid(team1 = rownames(uefa_playoff_team_strengths), team2 = rownames(uefa_playoff_team_strengths)) %>%
    as.data.frame() %>%
    filter(team1 != team2) %>%
    dplyr::mutate(
      team1_strength = uefa_playoff_team_strengths[team1, "ability"], team2_strength = uefa_playoff_team_strengths[team2, "ability"])
  
  possible_matchups = possible_matchups %>%
    left_join(domestic_strength %>%
                rename(team1 = Home)) %>%
    select(-c('Country','s.e.')) %>%
    rename(team1_domestic = ability)
  possible_matchups = possible_matchups %>%
    left_join(domestic_strength %>%
                rename(team2 = Home)) %>%
    select(-c('Country','s.e.')) %>%
    rename(team2_domestic = ability)
  
  possible_matchups = possible_matchups %>% mutate(
    prob = 1/(1+exp(-1*((team1_strength+(team1_domestic*lambda0_hat))-(team2_strength+(team2_domestic*lambda0_hat)))))
  )
})
possible_matchups
```

```{r, echo=FALSE}
group_stage = champs %>% filter(Round == 'Group stage') %>% select(-c('Competition_Name','Gender','Country', 'Season_End_Year', 'Wk', 'Date', 'Day','Time', 'Home_xG', 'Away_xG', 'Attendance', 'Referee', 'Notes','Venue', 'MatchURL')) %>%
    select(-c('Round')) %>%
    mutate(Home = str_replace(Home, ' [a-z]{2,3}$', ''),
           Away = str_replace(Away, '^[a-z]{2,3} ', ''))
group_stage
```

Since each round but the final takes place over two games, the chance of seeing the teams split the two games is high. Therefore, we need a way to choose a winner based on some other source of information. Thankfully, we have access to goal scoring data from the group stage, which we can use to make an informed estimation of the tie-breaking criteria that is used in this case in the actual UCL tournament: goal aggregate. For this, we'll take the mean of the goals scored for each team throughout the group stage and use it as the parameter for a Poisson distribution. Poisson distributions have long been used for simulating goals scored for a particular team, often utilizing the same methodology to choose the value of $\lambda$ [@poisson].

In other words, in the event of a tie between the two legs, we'll choose a goal value based on the following distribution:\
$$\lambda_i = \text{mean goals for team i in group stage}; \text{Draw from Pois}(\lambda_i)=\text{team i goals}$$

The helper function below will run a single iteration of our simulation:

```{r}
run_iteration = function(seed=439, verbose=FALSE){
  knockout = tibble(round = c(rep('Quarter', 4), c(rep('Semi', 2)), 'Final'), team1 = rep('',7), team2 = rep('',7), winner = rep('',7))
  knockout[1,'team1'] = 'RB Leipzig'
  knockout[1,'team2'] = 'Atlético Madrid'
  
  knockout[2,'team1'] = 'Atalanta'
  knockout[2,'team2'] = 'Paris S-G'
  
  knockout[3,'team1'] = 'Manchester City'
  knockout[3,'team2'] = 'Lyon'
  
  knockout[4,'team1'] = 'Barcelona'
  knockout[4,'team2'] = 'Bayern Munich'
  set.seed(seed)
  quarters = c()
  for(i in 1:4){
    team_a = knockout[i,] %>% pull('team1')
    team_b = knockout[i,] %>% pull('team2')
    prob_team1 = possible_matchups %>% filter(team1 == team_a & team2 == team_b) %>% pull('prob')
    if(verbose){
      print(str_c("Quarter ",i," Probability that team 1 ", team_a, " beats team 2 ", team_b, " :", prob_team1))
    }
    results = rbinom(n=2, size=1, prob=prob_team1)
    if(results[1] != results[2]){
      if(verbose){
        print(str_c(team_a, " and ", team_b, " split series. Using tie breaker..."))
      }
      mean_team1 = group_stage %>% filter(Home == team_a | Away == team_a) %>%
        mutate(TotGoals = case_when(Home == team_a ~ HomeGoals, Away == team_a ~ AwayGoals)) %>%
        select(TotGoals) %>% pull(TotGoals) %>% as.numeric() %>%
        mean()
      
      mean_team2 = group_stage %>% filter(Home == team_b | Away == team_b) %>%
        mutate(TotGoals = case_when(Home == team_b ~ HomeGoals, Away == team_b ~ AwayGoals)) %>%
        select(TotGoals) %>% pull(TotGoals) %>%
        as.numeric() %>%
        mean()
      
      ## choose winner
      team1_goals = rpois(1, mean_team1)
      team2_goals = rpois(1, mean_team2)
      while(team1_goals == team2_goals){
        team1_goals = rpois(1, mean_team1)
        team2_goals = rpois(1, mean_team2)
      }
      if(verbose){
        print(str_c(team_a, " scored ", team1_goals))
        print(str_c(team_b, " scored ", team2_goals))
      }
      if(team1_goals > team2_goals){
        winner = team_a
      }
      else {
        winner = team_b
      }
    }
    else if(sum(as.numeric(results)) == 2){
      winner = team_a
    }
    else{
      winner = team_b
    }
    quarters[length(quarters)+1] = winner
  }
  knockout[c(1:4),'winner']= quarters
  knockout[5,c('team1', 'team2')] = as.list(quarters[c(1,2)])
  knockout[6,c('team1', 'team2')] = as.list(quarters[c(3,4)])
  semis = c()
  for(i in 5:6){
    team_a = knockout[i,] %>% pull('team1')
    team_b = knockout[i,] %>% pull('team2')
    prob_team1 = possible_matchups %>% filter(team1 == team_a & team2 == team_b) %>% pull('prob')
    if(verbose){
      print(str_c("Semi ",i-4," Probability that team 1 ", team_a, " beats team 2 ", team_b, " :", prob_team1))
    }
    results = rbinom(n=2, size=1, prob=prob_team1)
    if(results[1] != results[2]){
      if(verbose){
        print(str_c(team_a, " and ", team_b, " split series. Using tie breaker..."))
      }
      mean_team1 = group_stage %>% filter(Home == team_a | Away == team_a) %>%
        mutate(TotGoals = case_when(Home == team_a ~ HomeGoals, Away == team_a ~ AwayGoals)) %>%
        select(TotGoals) %>% pull(TotGoals) %>% as.numeric() %>%
        mean()
      mean_team2 = group_stage %>% filter(Home == team_b | Away == team_b) %>%
        mutate(TotGoals = case_when(Home == team_b ~ HomeGoals, Away == team_b ~ AwayGoals)) %>%
        select(TotGoals) %>% pull(TotGoals) %>%
        as.numeric() %>%
        mean()
      ## choose winner
      team1_goals = rpois(1, mean_team1)
      team2_goals = rpois(1, mean_team2)
      while(team1_goals == team2_goals){
        team1_goals = rpois(1, mean_team1)
        team2_goals = rpois(1, mean_team2)
      }
      
      if(verbose){
        print(str_c(team_a, " scored ", team1_goals))
        print(str_c(team_b, " scored ", team2_goals))
      }
      if(team1_goals > team2_goals){
        winner = team_a
      }
      else {
        winner = team_b
      }
    }
    else if(sum(as.numeric(results)) == 2){
      winner = team_a
    }
    else{
      winner = team_b
    }
    semis[length(semis)+1] = winner
  }
  knockout[c(5:6),'winner']= semis
  knockout[7,c('team1', 'team2')] = as.list(semis[c(1,2)])
  i = 7
  team_a = knockout[i,] %>% pull('team1')
  team_b = knockout[i,] %>% pull('team2')
  prob_team1 = possible_matchups %>% filter(team1 == team_a & team_b == team2) %>% pull('prob')
  if(verbose){
    print(str_c("Final: Probability that team 1 ", team_a, " beats team 2 ", team_b, " :", prob_team1))
  }
  result = rbinom(n=1, size=1, prob=prob_team1)
  if(result == 1){
    winner = team_a
  } else {
    winner = team_b
  }
  if(verbose){
    print(str_c(winner, " WINS"))
  }
  knockout[7,'winner'] = winner
  return(knockout)
}
```

We'll run one simulation to get an idea of how the results are structured and use the `verbose` option to get a read of the simulation's stages.

```{r, echo=TRUE}
# Example of simulation when run verbose
run_iteration(verbose=TRUE)
```

```{r, echo=FALSE}
# Helper to run n iterations, starting small
run_n_iterations = function(n, seed=439, show_output=FALSE){
  n_iters = n
  sims = run_iteration()
  for(i in 2:n_iters){
    sims = sims %>% rbind(run_iteration(seed=seed*i, verbose=show_output))
  }
  return(sims)
}
sims = run_n_iterations(10)
sims %>% filter(round == 'Final') %>% group_by(winner) %>% count()
```

```{r}
# Medium-sized number of iterations
sims = run_n_iterations(1000, seed=12)
sims %>% filter(round == 'Final') %>% group_by(winner) %>% count()
```

After getting an idea of what type of results we should see, let's run the simulation 10,000 times to get an idea of how we would expect the tournament to play out given our conditions.

```{r eval=FALSE}
sims = run_n_iterations(10000)
```

```{r, echo=FALSE}
sims = read_csv('../data/simulations/SimulationResultsWithDomesticCovariate.csv', show_col_types = FALSE)
win_summary = sims %>% filter(round == 'Final') %>% group_by(winner) %>% count() %>% arrange(desc(n))
win_summary %>% mutate(prob = n/sum(win_summary$n))
```

```{r}
final_summary = sims %>% filter(round == 'Final') %>% group_by(team1, team2) %>% count() %>% arrange(desc(n))
final_summary %>% mutate(prob = n/sum(final_summary$n))
```

From the two tables above, we see both results that align with the real outcome of the tournament (PSG vs. Bayern) along with results that diverge from history (PSG winning the tournament). Overall, although the predicted winner, PSG, didn't win in real life, our results do roughly align with the match-ups and outcomes seen throughout the actual tournament. For instance, let's view the most common semifinal matchups:

```{r}
semi_summary = sims %>% filter(round == 'Semi') %>%
  group_by(team1, team2) %>% 
  count() %>%
  arrange(desc(n))
semi_summary %>% mutate(prob = n/sum(semi_summary$n))
```

The top two results, Manchester City vs. Bayern Munich and RB Leipzig vs. PSG were the two actual semifinal match-ups in the 2019-2020 tournament.

## Integrating Home Field Advantage

We can refine the model above by also taking into account the advantage derived from playing at home throughout the group stage. From this, we'll define the probability that team *i* beats team *j*, given team i and team j's domestic strengths, and if team i is playing at home. This probability can be expressed as, $$
\mathbb{P}(\text{team i with domestic strength x beats team j with domestic strength y at i's home}) = \frac{1}{1+e^{-1\times(((\lambda_i+x\lambda_0)+\lambda_1)-(\lambda_j+y\lambda_0))}}
$$

Thus, we'll restructure our results data frame to work with the `BradleyTerry2` package with the domestic strengths we previously used and an indicator *at.home* for whether team i was at home or not.

```{r, echo=TRUE}
unik_teams = sort(unique(c(no_ties$Home, no_ties$Away)))
results = no_ties %>% 
  left_join(domestic_strength%>% select(Home, ability), relationship='many-to-many') %>%
  rename(home.domestic = ability) %>%
  left_join(domestic_strength %>% rename(Away = Home) %>% select(Away, ability), relationship='many-to-many') %>% rename(away.domestic = ability) %>%
  rename(home.team = Home, away.team = Away) %>%
    group_by(home.team, away.team) %>%
    dplyr::summarise(
        home.win = sum(Home_Winner),
        away.win = sum(Opp_Winner),
        home.domestic = mean(home.domestic),
        away.domestic = mean(away.domestic), .groups = 'drop') |>
    dplyr::mutate(
        home.team = factor(home.team, levels = unik_teams),
        away.team = factor(away.team, levels = unik_teams),
        home.athome = 1,
        away.athome = 0)
```

```{r}
tmp = data.frame(home.win = results$home.win, away.win = results$away.win)
tmp$home.team = data.frame(
  team = results$home.team,
  domestic.strength = scale(results$home.domestic, center = TRUE, scale = TRUE)[,1],
  at.home = results$home.athome
)
tmp$away.team = data.frame(
  team = results$away.team,
  domestic.strength = scale(results$away.domestic, center = TRUE, scale = TRUE)[,1],
  at.home = results$away.athome
)
```

```{r, echo=TRUE}
suppressWarnings({
  fit <-
  BradleyTerry2::BTm(
    outcome = cbind(home.win, away.win),
    player1 = home.team, player2 = away.team,
    formula = ~ team + domestic.strength + at.home,
    refcat = "Dinamo Zagreb",
    id = "team",
    separate.ability = TRUE,
    data = tmp)
})
coef(fit)
```

From the above, we see that the raw coefficient given to home pitch advantage is approximately 0.065. However, to remain consistent with the normalization standards we've used throughout this section, we'll normalize this value given the mean and standard deviation of the previous coefficients.

```{r}
lambda1_hat = (0.06547312-mu_ability)/sd_ability
lambda1_hat
```

However, after this normalization, our home advantage coefficient is negative, suggesting there is a disadvantage to playing at home. While this isn't intuitive, given a history of literature in this area suggesting otherwise, it is possible that given this small sample, there was enough information to suggest this disadvantage. With that said, this is most likely due to the fact that we are normalizing this coefficient, which isn't necessarily standard in this form of model fitting. Later, we'll manually input a $\lambda$ for home advantage to determine if there is enough variation to indicate these results being faulty.

```{r, include=FALSE}
possible_matchups_w_home =
  expand.grid(team1 = rownames(uefa_playoff_team_strengths), team2 = rownames(uefa_playoff_team_strengths)) %>%
  as.data.frame() %>%
  filter(team1 != team2) %>%
  dplyr::mutate(
    team1_strength = uefa_playoff_team_strengths[team1, "ability"], team2_strength = uefa_playoff_team_strengths[team2, "ability"])

possible_matchups_w_home = possible_matchups_w_home %>%
  left_join(domestic_strength %>%
              rename(team1 = Home)) %>%
  select(-c('Country','s.e.')) %>%
  rename(team1_domestic = ability)
possible_matchups_w_home = possible_matchups_w_home %>%
  left_join(domestic_strength %>%
              rename(team2 = Home)) %>%
  select(-c('Country','s.e.')) %>%
  rename(team2_domestic = ability)

possible_matchups_w_home = possible_matchups_w_home %>%
  rename(home = team1, away = team2) %>% 
  mutate(
    prob = 1/(1+exp(-1*((team1_strength+(team1_domestic*lambda0_hat)+lambda1_hat)-(team2_strength+(team2_domestic*lambda0_hat)))))
  )
possible_matchups_w_home
```

Because we are now factoring in home vs. away in this version of our simulation, we have to track who's home during which leg. Throughout an actual tournament, in a two-leg round, each team plays one match at home. Thus, we've implemented this below, along with using the probability involving the normalized *at.home* coefficient.

```{r, include=FALSE}
run_iteration_w_home = function(seed=439, proba = possible_matchups_w_home){
  set.seed(seed)
  knockout = tibble(round = c(rep('Quarter', 8),c(rep('Semi', 4)), 'Final'), 
                    matchup_id = c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),rep(6,2),7), 
                    leg = c(rep(c(1,2),6), 1),home = rep('',13), away = rep('',13), 
                    leg_winner = rep('',13), 
                    round_winner = rep('', 13))
  knockout[1,'home'] = 'RB Leipzig'
  knockout[1,'away'] = 'Atlético Madrid'
  knockout[2,'home'] = 'Atlético Madrid'
  knockout[2,'away'] = 'RB Leipzig'
  
  knockout[3,'home'] = 'Atalanta'
  knockout[3,'away'] = 'Paris S-G'
  knockout[4,'home'] = 'Paris S-G'
  knockout[4,'away'] = 'Atalanta'
  
  knockout[5,'home'] = 'Manchester City'
  knockout[5,'away'] = 'Lyon'
  knockout[6,'home'] = 'Lyon'
  knockout[6,'away'] = 'Manchester City'
  
  knockout[7,'home'] = 'Barcelona'
  knockout[7,'away'] = 'Bayern Munich'
  knockout[8,'home'] = 'Bayern Munich'
  knockout[8,'away'] = 'Barcelona'
  quarters = c()
  for(offset in 1:4){
    for(i in 1:2){
    index = i+((offset-1)*2)
    team_a = knockout[index,] %>% pull('home')
    team_b = knockout[index,] %>% pull('away')
    prob_team1 = proba %>% filter(home == team_a & away == team_b) %>% pull('prob')
    results = rbinom(n=1, size=1, prob=prob_team1)
    if(sum(as.numeric(results)) == 1){
      winner = team_a
    }
    else{
      winner = team_b
    }
    knockout[index, 'leg_winner'] = winner
    if(i == 2){
      if(winner == knockout[index-1,]%>%pull('leg_winner')){
        knockout[index, 'round_winner'] = winner
        quarters[length(quarters)+1] = winner
      }
      else {
        mean_team1 = group_stage %>% filter(Home == team_a | Away == team_a) %>%
          mutate(TotGoals = case_when(Home == team_a ~ HomeGoals, Away == team_a ~ AwayGoals)) %>%
          select(TotGoals) %>% pull(TotGoals) %>% as.numeric() %>%
          mean()
        mean_team2 = group_stage %>% filter(Home == team_b | Away == team_b) %>%
          mutate(TotGoals = case_when(Home == team_b ~ HomeGoals, Away == team_b ~ AwayGoals)) %>%
          select(TotGoals) %>% pull(TotGoals) %>%
          as.numeric() %>%
          mean()
        ## choose winner
        team1_goals = rpois(1, mean_team1)
        team2_goals = rpois(1, mean_team2)
        while(team1_goals == team2_goals){
          team1_goals = rpois(1, mean_team1)
          team2_goals = rpois(1, mean_team2)
        }
        
        if(team1_goals > team2_goals){
          knockout[index, 'round_winner'] = team_a
          quarters[length(quarters)+1] = team_a
        }
        else {
          knockout[index, 'round_winner'] = team_b
          quarters[length(quarters)+1] = team_b
        }
      }
    }
  }
  }
  knockout[9,c('home', 'away')] = as.list(quarters[c(1,2)])
  knockout[10,c('home', 'away')] = as.list(rev(quarters[c(1,2)]))
  knockout[11,c('home', 'away')] = as.list(quarters[c(3,4)])
  knockout[12,c('home', 'away')] = as.list(rev(quarters[c(3,4)]))
  semis = c()
  for(offset in 5:6){
    for(i in 1:2){
      index = i+((offset-1)*2)
      team_a = knockout[index,] %>% pull('home')
      team_b = knockout[index,] %>% pull('away')
      prob_team1 = proba %>% filter(home == team_a & away == team_b) %>% pull('prob')
      results = rbinom(n=1, size=1, prob=prob_team1)
      if(sum(as.numeric(results)) == 1){
        winner = team_a
      }
      else{
        winner = team_b
      }
      knockout[index, 'leg_winner'] = winner
      if(i == 2){
        if(winner == knockout[index-1,]%>%pull('leg_winner')){
          knockout[index, 'round_winner'] = winner
          semis[length(semis)+1] = winner
        }
        else {
          mean_team1 = group_stage %>% filter(Home == team_a | Away == team_a) %>%
            mutate(TotGoals = case_when(Home == team_a ~ HomeGoals, Away == team_a ~ AwayGoals)) %>%
            select(TotGoals) %>% pull(TotGoals) %>% as.numeric() %>%
            mean()
          mean_team2 = group_stage %>% filter(Home == team_b | Away == team_b) %>%
            mutate(TotGoals = case_when(Home == team_b ~ HomeGoals, Away == team_b ~ AwayGoals)) %>%
            select(TotGoals) %>% pull(TotGoals) %>%
            as.numeric() %>%
            mean()
          ## choose winner
          team1_goals = rpois(1, mean_team1)
          team2_goals = rpois(1, mean_team2)
          while(team1_goals == team2_goals){
            team1_goals = rpois(1, mean_team1)
            team2_goals = rpois(1, mean_team2)
          }
          
          if(team1_goals > team2_goals){
            knockout[index, 'round_winner'] = team_a
            semis[length(semis)+1] = team_a
          }
          else {
            knockout[index, 'round_winner'] = team_b
            semis[length(semis)+1] = team_b
          }
        }
      }
    }
  }
  knockout[13,c('home', 'away')] = as.list(semis[c(1,2)])
  team_a = knockout[13,] %>% pull('home')
  team_b = knockout[13,] %>% pull('away')
  prob_team1 = possible_matchups %>% filter(team1 == team_a & team_b == team2) %>% pull('prob')
  
  result = rbinom(n=1, size=1, prob=prob_team1)
  if(result == 1){
    winner = team_a
  } else {
    winner = team_b
  }
  knockout[13,'leg_winner'] = winner
  knockout[13,'round_winner'] = winner
  return(knockout)
}
```

Again, let's start small, and get an idea of how our data will turn out.

```{r echo=FALSE}
run_n_iterations_w_home = function(n, seed=439){
  n_iters = n
  sims = run_iteration_w_home(seed)
  for(i in 2:n_iters){
    sims = sims %>% rbind(run_iteration_w_home(seed=seed*i))
  }
  return(sims)
}
sims = run_n_iterations_w_home(10)
sims %>% filter(round == 'Final') %>% group_by(round_winner) %>% count()
```

As mentioned earlier, we want to be able to modify the $\lambda_1$ value manually. So, we'll modify the helper to allow us to pass an argument to control this value.

```{r}
run_n_iterations_w_home = function(n, lambda, seed=439){
  matchups =
  expand.grid(team1 = rownames(uefa_playoff_team_strengths), team2 = rownames(uefa_playoff_team_strengths)) %>%
  as.data.frame() %>%
  filter(team1 != team2) %>%
  dplyr::mutate(
    team1_strength = uefa_playoff_team_strengths[team1, "ability"], team2_strength = uefa_playoff_team_strengths[team2, "ability"])

  matchups = matchups %>%
    left_join(domestic_strength %>%
                rename(team1 = Home), by='team1') %>%
    select(-c('Country','s.e.')) %>%
    rename(team1_domestic = ability)
  matchups = matchups %>%
    left_join(domestic_strength %>%
                rename(team2 = Home),  by='team2') %>%
    select(-c('Country','s.e.')) %>%
    rename(team2_domestic = ability)
  
  matchups = matchups %>%
    rename(home = team1, away = team2) %>% 
    mutate(
      prob = 1/(1+exp(-1*((team1_strength+(team1_domestic*lambda0_hat)+lambda)-(team2_strength+(team2_domestic*lambda0_hat)))))
    )
  n_iters = n
  sims = run_iteration_w_home(seed)
  for(i in 2:n_iters){
    sims = sims %>% rbind(run_iteration_w_home(seed=seed*i, proba=matchups))
  }
  return(sims)
}
```

Let's compare the results of simulating the knockout stages past the round of 16 with both $\lambda_1*$, the normalized lambda for home pitch advantage, as well as the original computation for $\lambda_1=0.065$

*Results of using* $\lambda_1=-0.0245$

```{r, echo=FALSE}
sims = run_n_iterations_w_home(1000, lambda1_hat)
sims %>% filter(round == 'Final') %>% group_by(round_winner) %>% count() %>% arrange(desc(n))
```

*Results of using* $\lambda_1=0.654$

```{r, echo=FALSE}
sims = run_n_iterations_w_home(1000, 0.06547312 )
sims %>% filter(round == 'Final') %>% group_by(round_winner) %>% count() %>% arrange(desc(n))
```

A surface-level analysis of the two results suggests that the normalized coefficient doesn't make much of an impact on the results of the model, with teams like PSG only seeing a change of 4.5% (413 vs. 435). Overall, the results do not significantly deviate from the standings computed when just using the domestic strength covariate, with Bayern, Manchester City, and PSG still leading the way.

*Summary of tournament winners with 10,000 simulations and* $\lambda_1=0.06547312$

```{r, echo=FALSE}
#sims = run_n_iterations_w_home(10000, 0.06547312)
sims = read_csv('../data/simulations/SimulationResultsWithDomesticAndHome.csv', show_col_types=FALSE)
winner_w_home_summary = sims %>% filter(round == 'Final') %>% group_by(round_winner) %>% count()
winner_w_home_summary = winner_w_home_summary %>% mutate(prob = n/sum(winner_w_home_summary$n)) %>% arrange(desc(n))
winner_w_home_summary
```

*Summary of final round match-ups with 10,000 simulations and* $\lambda_1=0.06547312$

```{r}
final_w_home_summary = sims %>% filter(round == 'Final') %>%
  group_by(home,away) %>% count() %>%
  mutate(prob = n/sum(winner_w_home_summary$n)) %>%
  arrange(desc(n))
final_w_home_summary
```

### Aside: $\lambda_1$ (Home Field Advantage) Impact

For a quick analysis into the impact of this $\lambda_1$ value, let's compare the percentage that Bayern wins the tournament at varying values of $\lambda_1$. We'll utilize `0.065`, `0.2`, and `0.5` as a baseline value, medium-strength value, and strong home field advantage value respectively.

```{r, echo=FALSE, include=FALSE}
lambda_summary = tibble(home_advantage = c(0.065, 0.2, 0.5), prob_win = c(0,0,0))
for(i in 1:nrow(lambda_summary)){
  sim = run_n_iterations_w_home(1000, lambda_summary[i,]%>%pull(home_advantage) )
  s = sim %>% filter(round == 'Final') %>%
    group_by(round_winner) %>% count()
  
  prob_win_b = s %>% mutate(prob = n/sum(s$n)) %>% arrange(desc(n)) %>%
    filter(round_winner == 'Bayern Munich') %>% pull(prob)
  lambda_summary[i,'prob_win'] = prob_win_b
}
```

```{r, echo=FALSE}
plot = ggplot(lambda_summary, aes(x=as.character(home_advantage), y=round(prob_win-0.3125, 3)*100, fill=as.character(home_advantage))) + geom_col() + scale_fill_manual(values = c("#99f2dd", "#4e60ba", "#0047ba")) + labs(title = '% Change in Probability of Bayern Munich Win By Home Advantage λ', x = 'λ', y = 'Probability of Bayern Munich Win') + guides(fill = guide_legend(title = 'Home Advantage λ'))
plot
```

The above graph shows that even with a substantial home field advantage, `0.5`, the observed effect is only a 1% increase in their win rate across 1,000 competitions.

## Summary: Knockout Simulation with Domestic Strengths, Home Field Covariates

As seen throughout this section, our results suggest that the real outcome of the 2019-2020 UEFA Champions League knockouts somewhat follow the expectation of our models. Whether with domestic strengths, or domestic strengths and home pitch advantage, we saw that the likeliest final was Bayern Munich-Paris S-G, with PSG winning the bulk of the simulations.

```{r, echo=FALSE}
forecasts <- read_csv('../data/simulations/SimulationResultsWithDomesticAndHome.csv', show_col_types = FALSE)
forecasts = forecasts %>% filter(round == 'Final') %>% group_by(round_winner) %>% count()
forecasts = forecasts %>% mutate(prob = n/sum(forecasts$n)) %>% arrange(desc(n)) %>% select(-c(n))

knockout_column <- function(maxWidth = 120, class = NULL, ...) {
  colDef(
    cell = format_pct,
    maxWidth = maxWidth,
    class = paste("cell number", class),
    style = function(value) {
      # Lighter color for <1%
      if (value < 0.01) {
        list(color = "#aaa")
      } else {
        list(color = "#111", background = knockout_pct_color(value))
      }
    },
    ...
  )
}

format_pct <- function(value) {
  if (value == 0) "  \u2013 "    # en dash for 0%
  else if (value == 1) "\u2713"  # checkmark for 100%
  else if (value < 0.01) " <1%"
  else if (value > 0.99) ">99%"
  else formatC(paste0(round(value * 100), "%"), width = 4)
}

make_color_pal <- function(colors, bias = 1) {
  get_color <- colorRamp(colors, bias = bias)
  function(x) rgb(get_color(x), maxColorValue = 255)
}

knockout_pct_color <- make_color_pal(c("#ffffff", "#f2fbd2", "#c9ecb4", "#93d3ab", "#35b0ab"), bias = 2)

tbl <- reactable(
  forecasts,
  pagination = FALSE,
  defaultSorted = "prob",
  defaultSortOrder = "desc",
  defaultColDef = colDef(
    vAlign = "center",
    headerVAlign = "bottom",
    class = "cell",
    headerClass = "header"
  ),
  columns = list(
    round_winner = colDef(
      name = "Team",
      defaultSortOrder = "asc",
      maxWidth = 250,
      headerStyle = list(fontWeight = 700),
      class = "cell team-name",
      cell = function(value, index) {
        div(
          class = "team",
          img(class = "team-flag", alt = sprintf("images/%s.png", value), src = sprintf("images/%s.png", value)),
          div(
            span(class = "team-name", value)
          )
        )
        }
    ),
    prob = knockout_column(name = "Win Tournament", maxWidth = 120)
  ),
  showSortIcon = FALSE,
  borderless = TRUE,
  class = "standings-table"
)

div(class = "standings",
  div(class = "title",
    h2("2019-2020 UEFA Champions League Simulation"),
    h3("Chances of each team winning tournament based on 10,000 simulations with two-legs in knockout rounds.")
  ),
  tbl
)
```

```{r, echo=FALSE}
final_matchups = sims %>% filter(round == 'Final') %>% group_by(home, away) %>% count() %>% arrange(desc(n)) %>% rename(team1 = home, team2 = away)
final_matchups$prob = final_matchups$n/sum(final_matchups$n)
forecasts = final_matchups %>% select(-c('n'))
tbl <- reactable(
  forecasts,
  pagination = FALSE,
  defaultSorted = "prob",
  defaultSortOrder = "desc",
  defaultColDef = colDef(
    vAlign = "center",
    headerVAlign = "bottom",
    class = "cell",
    headerClass = "header"
  ),
  columns = list(
    team1 = colDef(
      name = "Team 1",
      defaultSortOrder = "asc",
      maxWidth = 250,
      headerStyle = list(fontWeight = 700),
      class = "cell team-name",
      cell = function(value, index) {
        div(
          class = "team",
          img(class = "team-flag", alt = sprintf("images/%s.png", value), src = sprintf("images/%s.png", value)),
          div(
            span(class = "team-name", value)
          )
        )
        }
    ),
    team2 = colDef(
      name = "Team 2",
      defaultSortOrder = "asc",
      maxWidth = 250,
      headerStyle = list(fontWeight = 700),
      class = "cell team-name",
      cell = function(value, index) {
        div(
          class = "team",
          img(class = "team-flag", alt = sprintf("images/%s.png", value), src = sprintf("images/%s.png", value)),
          div(
            span(class = "team-name", value)
          )
        )
        }
    ),
    prob = knockout_column(name = "Made Final", maxWidth = 120)
  ),
  showSortIcon = FALSE,
  borderless = TRUE,
  class = "standings-table"
)

div(class = "standings",
  div(class = "title",
    h3("Chances of each team making tournament final based on 10,000 simulations with two-legs in knockout rounds."),
  ),
  tbl
)
```

### Challenges & Future Considerations

Throughout this section, we encountered several challenges that could see some improvement in the future. Namely, with fitting the Bradley-Terry models to the group stage, we saw significant deviations in team strengths, as well as missing values in model fitting due to the lack of team overlap in match-up results and a small sample size. Thus, our decisions to normalize the coefficients, as well as run several iterations of fitting to account for missing values may have skewed the team strengths somewhat. With that said, because our results aligned with those that played out in real life, there seems to be at least some merit to the process, including the use of domestic strengths as a covariate.

For future analyses of tournaments such as the UEFA Champions League, or other international competitions, it may be worthwhile to utilize simulations of not only the knockout stages, but also the group stages to observe a larger sample where deviations in results may be more evident. Further, a more detailed approach to breaking ties among aggregates could further differentiate our models from others, rather than utilizing the simplistic average goals-based Poisson model above.

```{r font_styles, include=FALSE}
htmltools::tags$link(
  href = "https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap",
  rel = "stylesheet"
)
```

```{css styles, include=FALSE}
.standings {
  font-family: "JetBrains Mono", "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 1.2em;
}

.team {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 0.75rem;
}

.team-flag {
  height: 3.75rem;
  margin-right: 0.25rem;
}

.title h3 {
  font-weight: 400;
}
```
