---
title: "Pre-processing & Deriving Conditional League Strengths"
output: html_notebook
editor_options: 
  chunk_output_type: inline
references:
- id: lecture12
  author:
  - family: Deshpande
    given: Sameer
  publisher: "University of Wisconsin-Madison"
  title: "Lecture 12: Bradley-Terry Models"
  type: lecture
  issued:
    year: 2025
  url: "https://skdeshpande91.github.io/stat479_fall2025/lectures/lecture12.html"
---

```{r echo=FALSE}
require(devtools, quietly = TRUE)
require(tidyverse, quietly = TRUE)
# devtools::install_github("hturner/BradleyTerry2")
require(BradleyTerry2, quietly = TRUE)
#devtools::install_github("hrbrmstr/hrbrthemes", quiet = TRUE)
#require(hrbrthemes, quietly = TRUE)
```

## Data Overview

The following data was gathered using the `worldfootballR` library to scrape 2019-20 UEFA Champions League group stage and knockout game results and the 2018-19 domestic league results for the 32 competing teams across 16 individual league competitions[^1] from [fbref.com](https://www.fbref.com).

[^1]: Members from the following domestic leagues took part in the 2019-20 UEFA Champions League group stage: *Austrian Football Bundesliga, Belgian Pro League, Croatian Football League, Czech First League, English Premier League, French Ligue 1, German Fusball Bundesliga, Greek Super League, Italian Serie A, Dutch Eredivise, Portugese Premeira Liga, Russian Premier League, Serbian SuperLiga, Spanish La Liga, Turkish Super Lig, Ukrainian Premier League*

```{r echo=FALSE}
## Read in all league results
austria = readr::read_csv('../data/raw/Austria_Austrian_Football_Bundesliga_2018-19.csv', show_col_types = FALSE)
belgium = readr::read_csv('../data/raw/Belgium_Belgian_Pro_League_2018-19.csv', show_col_types = FALSE)
croatia = readr::read_csv('../data/raw/Croatia_Croatian_Football_League_2018-19.csv', show_col_types = FALSE)
czech = readr::read_csv('../data/raw/Czechia_Czech_First_League_2018-19.csv', show_col_types = FALSE)
england = readr::read_csv('../data/raw/England_Premier_League_2018-19.csv', show_col_types = FALSE)
france = readr::read_csv('../data/raw/France_Ligue_1_2018-19.csv', show_col_types = FALSE)
germany = readr::read_csv('../data/raw/Germany_Fusball_Bundesliga_2018-19.csv', show_col_types = FALSE)
greece = readr::read_csv('../data/raw/Greece_Super_League_Greece_2018-19.csv', show_col_types = FALSE)
italy = readr::read_csv('../data/raw/Italy_Serie_A_2018-19.csv', show_col_types = FALSE)
nether = readr::read_csv('../data/raw/Netherlands_Eredivise_2018-19.csv', show_col_types = FALSE)
portugal = readr::read_csv('../data/raw/Portugal_Premeira_Liga_2018-19.csv', show_col_types = FALSE)
russia = readr::read_csv('../data/raw/Russia_Russian_Premier_League_2018-19.csv', show_col_types = FALSE)
serbia = readr::read_csv('../data/raw/Serbia_Serbian_SuperLiga_2018-19.csv', show_col_types = FALSE)
spain = readr::read_csv('../data/raw/Spain_La_Liga_2018-19.csv', show_col_types = FALSE)
turkey = readr::read_csv('../data/raw/Turkiye_Super_Lig_2018-19.csv', show_col_types = FALSE)
ukraine = readr::read_csv('../data/raw/Ukraine_Ukrainian_Premier_League_2018-19.csv', show_col_types = FALSE)
```

## Data Pre-processing

In order to use the domestic competition and UEFA Champions League matchup data scraped from [fbref.com](https://www.fbref.com/)[^2] with the Bradley-Terry package, `BradleyTerry2`, the raw data must first be cleaned, parsed, and reformated into the package's expected format. This code follows that found in Lecture 12 [@lecture12], particularly when refactoring home and away win data into a trainable DataFrame.

[^2]: Specific links and FBRef pages used can be found in the *GettingRawMatchupData.Rmd* notebook.

```{r}
# Helper to remove xG columns from relevant leagues so all competitions have the same number of columns
remove_xg = function(df){ 
  if((df %>% select(contains('_xG')) %>% length()) > 0){
    return(df %>% select(-contains('_xG')))
  }
  else {
    return(df)
  }
}
austria = remove_xg(austria)
belgium = remove_xg(belgium)
croatia = remove_xg(croatia)
czech = remove_xg(czech)
england = remove_xg(england)
france = remove_xg(france)
germany = remove_xg(germany)
greece = remove_xg(greece)
italy = remove_xg(italy)
nether = remove_xg(nether)
portugal = remove_xg(portugal)
russia = remove_xg(russia)
serbia = remove_xg(serbia)
spain = remove_xg(spain)
turkey = remove_xg(turkey)
ukraine = remove_xg(ukraine)
```

```{r}
# Concatenate all leagues together
all = austria %>%
  rbind(belgium) %>%
  rbind(croatia) %>%
  rbind(czech) %>%
  rbind(england) %>%
  rbind(france) %>%
  rbind(germany) %>%
  rbind(greece) %>%
  rbind(italy) %>%
  rbind(nether) %>%
  rbind(portugal) %>%
  rbind(russia) %>%
  rbind(serbia) %>%
  rbind(spain) %>%
  rbind(turkey) %>%
  rbind(ukraine)
all %>% head(10)
```

With the leagues all concatenated together, we can check to see the distribution of the complete DataFrame's members.

```{r, echo=FALSE}
set.seed(439)
all[sample(1:nrow(all), size=10),]
```

```{r, echo = FALSE}
matches_by_country = all %>%
  group_by(Country) %>%
  count(.drop = TRUE)

plot = ggplot2::ggplot(matches_by_country, aes(x = Country, y = n)) + 
  ggplot2::geom_col() + 
  labs(
    title = "2018-19 Domestic League Matches By Competing Nation",
    x = "UEFA Country",
    y = "Number of Matches"
  ) +
  ggplot2::theme_minimal()  # clean built-in ggplot2 theme

plot

```

```{r}
# CODE FROM LECTURE 12
# results <-
#  no_ties |>
#  dplyr::rename(home.team = Home, away.team = Opponent) |>
#  dplyr::group_by(home.team, away.team) |>
#  dplyr::summarise(
#    home.win = sum(Home_Winner),
#    away.win = sum(Opp_Winner), .groups = 'drop') |>
#  dplyr::mutate(
#    home.team = factor(home.team, levels = unik_teams),
#    away.team = factor(away.team,levels = unik_teams))
no_ties = all %>% filter(HomeGoals != AwayGoals) %>%
  filter(!str_detect(Round, "play-offs") | is.na(Round)) %>% ## removing matchups in pro/rel playoffs, otherwise we'll see skewed strengths for those leagues
  mutate(Home_Winner = case_when(HomeGoals > AwayGoals ~ 1, .default=0),
         Opp_Winner = case_when(AwayGoals > HomeGoals ~ 1, .default=0))

unik_teams = sort(unique(c(no_ties$Home, no_ties$Away)))

results = no_ties %>% 
  rename(home.team = Home, away.team = Away) %>%
  group_by(home.team, away.team) %>%
  dplyr::summarise(
    home.win = sum(Home_Winner),
    away.win = sum(Opp_Winner), .groups = 'drop') |>
  dplyr::mutate(
    home.team = factor(home.team, levels = unik_teams),
    away.team = factor(away.team, levels = unik_teams))
results[sample(1:nrow(results),size=10),]
```

With the data now in place and formatted for `BradleyTerry2`, we can begin fitting a Bradley-Terry model to determine latent team strength for all clubs competing in the 2019-20 UEFA Champions League group stage based on their domestic league results.

## Fitting Bradley-Terry Model Based on Domestic League Results

For this problem, we'll use the worst performing team in the lowest-rated domestic competition based on the UEFA association club coefficient[^3] for the 2018-19 season, which can be found at [UEFA.com](https://www.uefa.com/nationalassociations/uefarankings/country/?year=2019).

[^3]: <https://en.wikipedia.org/wiki/UEFA_coefficient>

Based on the table below, Greece had the lowest rating of the 16 nations represented by clubs in the 2019-20 tournament.

#### Table: 2018-19 UEFA association club coefficients for competing nations

```{r}
read_csv('../data/raw/League_Participant_Info_2018-19.csv') %>%
  select(full_name, last_association_coef) %>%
  rename(Country = full_name, Coefficient = last_association_coef) %>%
  arrange(desc(Coefficient))
```

In the 2018-19 season of the Greek Super League, *Apollon Smyrnis* finished in last place[^4], so we'll use them as our reference for fitting the Bradley-Terry model.

[^4]: <https://en.wikipedia.org/wiki/2018%E2%80%9319_Super_League_Greece#League_table>

```{r}
fit <-
  BradleyTerry2::BTm(
    outcome = cbind(home.win, away.win),
    player1 = home.team, player2 = away.team,
    refcat = "Yenisey",
    data = results)
summary(fit)
```

```{r}
lambda_hat = as.data.frame(BradleyTerry2::BTabilities(fit))
lambda_hat = lambda_hat %>% drop_na() %>% arrange(desc(ability))
lambda_hat = rownames_to_column(lambda_hat) %>% rename(team = rowname)
lambda_hat
```

Given the summary of the Bradley-Terry model and its resulting team strengths, it seems that the results were relatively sensitive to positive results for teams in skewed competitions. In other words, in leagues that are typically dominated by a small number of teams (Greece, Czechia), results over and by the top teams in the competitions were "rewarded" more than their counterparts in other "fairer" competitions (England, Spain). Subjectively, clubs like Slavia Prague typically due dominant their domestic competition, which means we would expect a high "ability" assignment, like we see in this model.

For the sake of our project, we'll only focus on the strengths of the clubs competing in the 2019-20 UEFA Champions League group stages. From this, we see the aforementioned Slavia Prague leading in "domestic strength", along with other dominant teams from smaller nations, like Olympiacos from Greece and Dinamo Zagreb from Croatia. This aligns with our prior assumptions,

```{r, echo=FALSE}
uefa = read_csv('../data/raw/UEFA_Champions_League_2020_Results_RAW.csv') 
uefa = uefa %>% select(Home) %>% mutate(Country = str_extract(uefa$Home, " [a-z]{2,3}$"), Home = str_remove(uefa$Home, " [a-z]{2,3}$")) %>% select(Home, Country, everything())
champs_w_league_ratings = uefa %>% left_join(lambda_hat %>% rename(Home = team)) %>% unique() %>% replace(is.na(.), 0)
champs_w_league_ratings %>% arrange(desc(ability))
```

```{r, echo=FALSE}
strongest = champs_w_league_ratings %>% arrange(desc(ability)) %>% head(5)
plot = ggplot2::ggplot(strongest, aes(Home, ability)) + 
  ggplot2::geom_col() + 
  labs(title = "Top 5 Teams by 2018-19 Domestic Performance Strength", x = "Club", y = "Team Strength Î»") + 
  ggplot2::theme_minimal()
plot
```

Since the round of 16 for the Champions League Tournament had 2 legs before COVID officially shut down the tournament, we need to simulate both legs of the contest. However our Bradley-Terry model has limitations where it doesn't predict score just the overall winner. For 2 leg contests, this shows a problem where aggregate score decides the winner. If both teams win one game, the Bradley Terry model doesn't know who wins the whole round. Also, if one team wins marginally, and the other team wins by a lot, it still looks like 1 win and 1 loss to the Bradley Terry model. This is the reason that we want to get the scores of the matchups, so we shift for this round specifically to a Markov Chain model modeling states of the games using the Bradley-Terry strengths to simulate goal scores and state changes.

```{r}
total_gpm <- 2.7   # constant, estimated how many goals are scored per game
beta      <- 0.9   # how strongly BT ability difference tilts scoring share
hfa       <- 0.28  # home-field advantage in the scoring-share logit
et_scale  <- 0.75  # scoring slows in extra time
set.seed(479)

inv_logit <- function(x) 1/(1+exp(-x))
# ---- normalize and safely match team names to lambda_hat$team ----
normalize_name <- function(x) {
  y <- iconv(x, from = "", to = "ASCII//TRANSLIT")
  y <- tolower(y)
  gsub("[^a-z0-9]+", "", y)
}

lambda_vec_raw <- setNames(lambda_hat$ability, lambda_hat$team)
teams_raw  <- names(lambda_vec_raw)
teams_norm <- normalize_name(teams_raw)

get_lambda <- function(team) {
  key <- normalize_name(team)
  idx <- match(key, teams_norm)
  if (!is.na(idx)) return(lambda_vec_raw[[teams_raw[idx]]])
  d <- adist(key, teams_norm)
  idx <- which.min(d)
  if (length(idx) == 1 && is.finite(d[idx])) return(lambda_vec_raw[[teams_raw[idx]]])
  0
}

# helpful preview to ensure aliases look right
map_team <- function(team) {
  key <- normalize_name(team)
  idx <- match(key, teams_norm)
  if (!is.na(idx)) {
    data.frame(input=team, matched=teams_raw[idx], method="exact", stringsAsFactors=FALSE)
  } else {
    d <- adist(key, teams_norm); idx <- which.min(d)
    data.frame(input=team, matched=teams_raw[idx], method=paste0("fuzzy:d=", d[idx]), stringsAsFactors=FALSE)
  }
}
```

Some of the names of teams vary, so we have some normalization functions to keep the team names standard.

```{r}
r16_ties <- tibble::tribble(
  ~tie_id, ~home_first_leg,     ~away_first_leg,
  "R16-1", "Atalanta",          "Valencia",
  "R16-2", "Dortmund",          "Paris S-G",
  "R16-3", "Atletico Madrid",   "Liverpool",
  "R16-4", "Tottenham",         "RB Leipzig",
  "R16-5", "Chelsea",           "Bayern Munich",
  "R16-6", "Napoli",            "Barcelona",
  "R16-7", "Real Madrid",       "Manchester City",
  "R16-8", "Lyon",              "Juventus"
)

# show how each R16 name maps into your lambda_hat list
r16_name_map <- unique(rbind(
  do.call(rbind, lapply(r16_ties$home_first_leg, map_team)),
  do.call(rbind, lapply(r16_ties$away_first_leg, map_team))
))
print(r16_name_map, row.names = FALSE)
```

```{r}
sim_match_markov <- function(Home, Away, neutral=FALSE, allow_et=TRUE) {
  lamH <- get_lambda(Home); lamA <- get_lambda(Away)
  r_tot <- total_gpm / 90   # total goal probability per minute
  s_home <- inv_logit(beta * (lamH - lamA) + ifelse(neutral, 0, hfa))
  pH <- r_tot * s_home
  pA <- r_tot * (1 - s_home)

  gH <- 0L; gA <- 0L
  for (t in 1:90) {
    u <- runif(1)
    if (u < pH) gH <- gH + 1L else if (u < pH + pA) gA <- gA + 1L
  }
  if (allow_et && gH == gA) {
    pH_et <- pH * et_scale; pA_et <- pA * et_scale
    for (t in 1:30) {
      u <- runif(1)
      if (u < pH_et) gH <- gH + 1L else if (u < pH_et + pA_et) gA <- gA + 1L
    }
    if (gH == gA) {
      # Penalties with slight tilt by team strength
      base <- 0.76; tilt <- 0.02
      p_home <- max(min(base + tilt * tanh(lamH - lamA), 0.95), 0.55)
      p_away <- max(min(base - tilt * tanh(lamH - lamA), 0.95), 0.55)
      a <- b <- 0L
      for (i in 1:5) { a <- a + rbinom(1,1,p_home); b <- b + rbinom(1,1,p_away) }
      if (a != b) return(list(gH=gH, gA=gA, mode="PK", winner=ifelse(a>b,"home","away")))
      repeat {
        aa <- rbinom(1,1,p_home); bb <- rbinom(1,1,p_away)
        if (aa != bb) return(list(gH=gH, gA=gA, mode="PK", winner=ifelse(aa>bb,"home","away")))
      }
    }
    return(list(gH=gH, gA=gA, mode="ET", winner=ifelse(gH>gA,"home","away")))
  }
  list(gH=gH, gA=gA, mode="FT", winner=ifelse(gH>gA,"home","away"))
}

```

```{r}
sim_two_leg_markov <- function(A, B, away_goals_rule=TRUE) {
  # Leg 1: A home
  L1 <- sim_match_markov(A, B, neutral=FALSE, allow_et=FALSE)
  # Leg 2: B home
  L2 <- sim_match_markov(B, A, neutral=FALSE, allow_et=FALSE)

  aggA <- L1$gH + L2$gA
  aggB <- L1$gA + L2$gH
  if (aggA != aggB) return(list(winner=ifelse(aggA>aggB, A, B),
                                aggA=aggA, aggB=aggB, decided="AGG"))
  if (away_goals_rule) {
    A_away <- L2$gA; B_away <- L1$gA
    if (A_away != B_away)
      return(list(winner=ifelse(A_away>B_away, A, B),
                  aggA=aggA, aggB=aggB, decided="AWAY_GOALS"))
  }
  # ET in Leg 2 (B home)
  lamB <- get_lambda(B); lamA <- get_lambda(A)
  r_tot <- total_gpm / 90
  s_home <- inv_logit(beta * (lamB - lamA) + hfa)
  pH_et <- (r_tot * s_home) * et_scale
  pA_et <- (r_tot * (1 - s_home)) * et_scale
  gH_et <- 0L; gA_et <- 0L
  for (t in 1:30) {
    u <- runif(1)
    if (u < pH_et) gH_et <- gH_et + 1L else if (u < pH_et + pA_et) gA_et <- gA_et + 1L
  }
  aggA2 <- aggA + gA_et
  aggB2 <- aggB + gH_et
  if (aggA2 != aggB2)
    return(list(winner=ifelse(aggA2>aggB2, A, B),
                aggA=aggA2, aggB=aggB2, decided="ET"))

  # PKs
  base <- 0.76; tilt <- 0.02
  p_home <- max(min(base + tilt * tanh(lamB - lamA), 0.95), 0.55)
  p_away <- max(min(base - tilt * tanh(lamB - lamA), 0.95), 0.55)
  a <- b <- 0L
  for (i in 1:5) { a <- a + rbinom(1,1,p_home); b <- b + rbinom(1,1,p_away) }
  if (a != b) return(list(winner=ifelse(a>b, B, A),
                          aggA=aggA2, aggB=aggB2, decided="PK"))
  repeat {
    aa <- rbinom(1,1,p_home); bb <- rbinom(1,1,p_away)
    if (aa != bb) return(list(winner=ifelse(aa>bb, B, A),
                              aggA=aggA2, aggB=aggB2, decided="PK"))
  }
}
```

```{r}
simulate_r16_mc <- function(N=5000, away_goals_rule=TRUE) {
  purrr::map_dfr(seq_len(nrow(r16_ties)), function(i) {
    A <- r16_ties$home_first_leg[i]
    B <- r16_ties$away_first_leg[i]
    winsA <- 0L; sumAggA <- 0; sumAggB <- 0
    for (k in 1:N) {
      out <- sim_two_leg_markov(A, B, away_goals_rule=away_goals_rule)
      if (out$winner == A) winsA <- winsA + 1L
      sumAggA <- sumAggA + out$aggA
      sumAggB <- sumAggB + out$aggB
    }
    pA <- winsA / N
    tibble::tibble(
      tie_id = r16_ties$tie_id[i],
      team_A = A, team_B = B,
      p_adv_A = pA,
      p_adv_B = 1 - pA,
      se_A = sqrt(pA*(1-pA)/N),
      mean_agg_A = sumAggA / N,
      mean_agg_B = sumAggB / N
    )
  }) %>% dplyr::arrange(tie_id)
}
```

```{r}

N <- 5000
r16_results <- simulate_r16_mc(N=N, away_goals_rule=TRUE)
print(r16_results)

```

The results show that Atalanta is slightly favored over Valencia, but it is pretty much a tossup at p = 0.52.

PSG, Liverpool, Barcelona, Manchester city, Bayern Munich and Juventus are heavily favored in their matchups with around an 80 percent chance to win.

RB Leipzig is slightly favored in their matchup with a 60 percent chance of winning.

This aligns as in real life, Bayern, Manchester City, Barcelona, and PSG all won their matchups.

Leipzig and and Atalanta also won their matchups.

However, Liverpool was Upset along with Juventus.

## Endnotes {#endnotes}

## References

```{js, echo=FALSE}
$(document).ready(function() {
  $('.footnotes ol').appendTo('#endnotes');
  $('.footnotes').remove();
});
```
