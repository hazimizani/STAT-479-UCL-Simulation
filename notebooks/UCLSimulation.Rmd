---
title: "Pre-processing & Deriving Conditional League Strengths"
output: html_notebook
editor_options: 
  chunk_output_type: inline
references:
- id: lecture12
  author:
  - family: Deshpande
    given: Sameer
  publisher: "University of Wisconsin-Madison"
  title: "Lecture 12: Bradley-Terry Models"
  type: lecture
  issued:
    year: 2025
  url: "https://skdeshpande91.github.io/stat479_fall2025/lectures/lecture12.html"
---


```{r echo=FALSE}
require(devtools, quietly = TRUE)
require(tidyverse, quietly = TRUE)
# devtools::install_github("hturner/BradleyTerry2")
require(BradleyTerry2, quietly = TRUE)
devtools::install_github("hrbrmstr/hrbrthemes", quiet = TRUE)
require(hrbrthemes, quietly = TRUE)
```

## Data Overview
The following data was gathered using the `worldfootballR` library to scrape 2019-20 UEFA Champions League group stage and knockout game results and the 2018-19 domestic league results for the 32 competing teams across 16 individual league competitions^[Members from the following domestic leagues took part in the 2019-20 UEFA Champions League group stage: *Austrian Football Bundesliga, Belgian Pro League, Croatian Football League, Czech First League, English Premier League, French Ligue 1, German Fusball Bundesliga, Greek Super League, Italian Serie A, Dutch Eredivise, Portugese Premeira Liga, Russian Premier League, Serbian SuperLiga, Spanish La Liga, Turkish Super Lig, Ukrainian Premier League*] from [fbref.com](https://www.fbref.com).

```{r echo=FALSE}
## Read in all league results
austria = readr::read_csv('../data/raw/Austria_Austrian_Football_Bundesliga_2018-19.csv', show_col_types = FALSE)
belgium = readr::read_csv('../data/raw/Belgium_Belgian_Pro_League_2018-19.csv', show_col_types = FALSE)
croatia = readr::read_csv('../data/raw/Croatia_Croatian_Football_League_2018-19.csv', show_col_types = FALSE)
czech = readr::read_csv('../data/raw/Czechia_Czech_First_League_2018-19.csv', show_col_types = FALSE)
england = readr::read_csv('../data/raw/England_Premier_League_2018-19.csv', show_col_types = FALSE)
france = readr::read_csv('../data/raw/France_Ligue_1_2018-19.csv', show_col_types = FALSE)
germany = readr::read_csv('../data/raw/Germany_Fusball_Bundesliga_2018-19.csv', show_col_types = FALSE)
greece = readr::read_csv('../data/raw/Greece_Super_League_Greece_2018-19.csv', show_col_types = FALSE)
italy = readr::read_csv('../data/raw/Italy_Serie_A_2018-19.csv', show_col_types = FALSE)
nether = readr::read_csv('../data/raw/Netherlands_Eredivise_2018-19.csv', show_col_types = FALSE)
portugal = readr::read_csv('../data/raw/Portugal_Premeira_Liga_2018-19.csv', show_col_types = FALSE)
russia = readr::read_csv('../data/raw/Russia_Russian_Premier_League_2018-19.csv', show_col_types = FALSE)
serbia = readr::read_csv('../data/raw/Serbia_Serbian_SuperLiga_2018-19.csv', show_col_types = FALSE)
spain = readr::read_csv('../data/raw/Spain_La_Liga_2018-19.csv', show_col_types = FALSE)
turkey = readr::read_csv('../data/raw/Turkiye_Super_Lig_2018-19.csv', show_col_types = FALSE)
ukraine = readr::read_csv('../data/raw/Ukraine_Ukrainian_Premier_League_2018-19.csv', show_col_types = FALSE)
```

## Data Pre-processing
In order to use the domestic competition and UEFA Champions League matchup data scraped from [fbref.com](https://www.fbref.com/)^[Specific links and FBRef pages used can be found in the *GettingRawMatchupData.Rmd* notebook.] with the Bradley-Terry package, `BradleyTerry2`, the raw data must first be cleaned, parsed, and reformated into the package's expected format. This code follows that found in Lecture 12 [@lecture12], particularly when refactoring home and away win data into a trainable DataFrame.

```{r}
# Helper to remove xG columns from relevant leagues so all competitions have the same number of columns
remove_xg = function(df){ 
  if((df %>% select(contains('_xG')) %>% length()) > 0){
    return(df %>% select(-contains('_xG')))
  }
  else {
    return(df)
  }
}
austria = remove_xg(austria)
belgium = remove_xg(belgium)
croatia = remove_xg(croatia)
czech = remove_xg(czech)
england = remove_xg(england)
france = remove_xg(france)
germany = remove_xg(germany)
greece = remove_xg(greece)
italy = remove_xg(italy)
nether = remove_xg(nether)
portugal = remove_xg(portugal)
russia = remove_xg(russia)
serbia = remove_xg(serbia)
spain = remove_xg(spain)
turkey = remove_xg(turkey)
ukraine = remove_xg(ukraine)
```

```{r}
# Concatenate all leagues together
all = austria %>%
  rbind(belgium) %>%
  rbind(croatia) %>%
  rbind(czech) %>%
  rbind(england) %>%
  rbind(france) %>%
  rbind(germany) %>%
  rbind(greece) %>%
  rbind(italy) %>%
  rbind(nether) %>%
  rbind(portugal) %>%
  rbind(russia) %>%
  rbind(serbia) %>%
  rbind(spain) %>%
  rbind(turkey) %>%
  rbind(ukraine)
all %>% head(10)
```
With the leagues all concatenated together, we can check to see the distribution of the complete DataFrame's members.
```{r, echo=FALSE}
set.seed(439)
all[sample(1:nrow(all), size=10),]
```
```{r, echo = FALSE}
matches_by_country = all %>%
                        group_by(Country) %>%
                        count(.drop = TRUE)

plot = ggplot2::ggplot(matches_by_country, aes(matches_by_country$Country, matches_by_country$n)) + 
  ggplot2::geom_col() + 
  labs(title = "2018-19 Domestic League Matches By Competing Nation", x = "UEFA Country", y = "Number of Matches") + 
  hrbrthemes::theme_ipsum(grid="Y")
plot
```

```{r}
# CODE FROM LECTURE 12
# results <-
#  no_ties |>
#  dplyr::rename(home.team = Home, away.team = Opponent) |>
#  dplyr::group_by(home.team, away.team) |>
#  dplyr::summarise(
#    home.win = sum(Home_Winner),
#    away.win = sum(Opp_Winner), .groups = 'drop') |>
#  dplyr::mutate(
#    home.team = factor(home.team, levels = unik_teams),
#    away.team = factor(away.team,levels = unik_teams))
no_ties = all %>% filter(HomeGoals != AwayGoals) %>%
  filter(!str_detect(Round, "play-offs") | is.na(Round)) %>% ## removing matchups in pro/rel playoffs, otherwise we'll see skewed strengths for those leagues
  mutate(Home_Winner = case_when(HomeGoals > AwayGoals ~ 1, .default=0),
         Opp_Winner = case_when(AwayGoals > HomeGoals ~ 1, .default=0))

unik_teams = sort(unique(c(no_ties$Home, no_ties$Away)))

results = no_ties %>% 
  rename(home.team = Home, away.team = Away) %>%
  group_by(home.team, away.team) %>%
  dplyr::summarise(
    home.win = sum(Home_Winner),
    away.win = sum(Opp_Winner), .groups = 'drop') |>
  dplyr::mutate(
    home.team = factor(home.team, levels = unik_teams),
    away.team = factor(away.team, levels = unik_teams))
results[sample(1:nrow(results),size=10),]
```
With the data now in place and formatted for `BradleyTerry2`, we can begin fitting a Bradley-Terry model to determine latent team strength for all clubs competing in the 2019-20 UEFA Champions League group stage based on their domestic league results.

## Fitting Bradley-Terry Model Based on Domestic League Results
For this problem, we'll use the worst performing team in the lowest-rated domestic competition based on the UEFA association club coefficient^[https://en.wikipedia.org/wiki/UEFA_coefficient] for the 2018-19 season, which can be found at [UEFA.com](https://www.uefa.com/nationalassociations/uefarankings/country/?year=2019).

Based on the table below, Greece had the lowest rating of the 16 nations represented by clubs in the 2019-20 tournament.

#### Table: 2018-19 UEFA association club coefficients for competing nations
```{r}
country_coefficients = read_csv('../data/raw/League_Participant_Info_2018-19.csv') %>%
  select(full_name, last_association_coef) %>%
  rename(Country = full_name, Coefficient = last_association_coef) %>%
  arrange(desc(Coefficient))

country_coefficients
```
In the 2018-19 season of the Russian League, *Yenisey* finished in last place, so we'll use them as our reference for fitting the Bradley-Terry model.
```{r}
fit <-
  BradleyTerry2::BTm(
    outcome = cbind(home.win, away.win),
    player1 = home.team, player2 = away.team,
    refcat = "Yenisey",
    data = results)
summary(fit)
```

```{r}
lambda_hat = as.data.frame(BradleyTerry2::BTabilities(fit))
lambda_hat = lambda_hat %>% drop_na() %>% arrange(desc(ability))
lambda_hat = rownames_to_column(lambda_hat) %>% rename(team = rowname)
lambda_hat
```
Given the summary of the Bradley-Terry model and its resulting team strengths, it seems that the results were relatively sensitive to positive results for teams in skewed competitions. In other words, in leagues that are typically dominated by a small number of teams (Greece, Czechia), results over and by the top teams in the competitions were "rewarded" more than their counterparts in other "fairer" competitions (England, Spain). Subjectively, clubs like Slavia Prague typically due dominant their domestic competition, which means we would expect a high "ability" assignment, like we see in this model.

For the sake of our project, we'll only focus on the strengths of the clubs competing in the 2019-20 UEFA Champions League group stages and round of 16. From this, we see the aforementioned Slavia Prague leading in "domestic strength", along with other dominant teams from smaller nations, like Olympiacos from Greece and Dinamo Zagreb from Croatia. This aligns with our prior assumptions,

```{r, echo=FALSE}
uefa = read_csv('../data/raw/UEFA_Champions_League_2020_Results_RAW.csv') 
uefa = uefa %>% select(Home) %>% mutate(Country = str_extract(uefa$Home, " [a-z]{2,3}$"), Home = str_remove(uefa$Home, " [a-z]{2,3}$")) %>% select(Home, Country, everything())
champs_w_league_ratings = uefa %>% left_join(lambda_hat %>% rename(Home = team)) %>% unique() %>% replace(is.na(.), 0)
champs_w_league_ratings %>% arrange(desc(ability))
```
```{r, echo=FALSE}
strongest = champs_w_league_ratings %>% arrange(desc(ability)) %>% head(5)
plot = ggplot2::ggplot(strongest, aes(Home, ability)) + 
  ggplot2::geom_col() + 
  labs(title = "Top 5 Teams by 2018-19 Domestic Performance Strength", x = "Club", y = "Team Strength λ") + 
  hrbrthemes::theme_ipsum(grid="Y")
plot
```


```{r}
uefa_playoff_teams = uefa %>%
  filter(Round %in% c("Quarter-finals", "Semi-finals", "Final")) %>% select(Home, Away) %>%
  unlist(use.names = FALSE) %>% unique() 

uefa_playoff_teams 
```

```{r}
all_combined = bind_rows(
  all %>% mutate(Competition = "Domestic"),
  uefa %>% mutate(Competition = "UCL")
)

no_ties_combined = all_combined %>%
  filter(HomeGoals != AwayGoals) %>%
  mutate(Home_Winner = as.numeric(HomeGoals > AwayGoals),
         Opp_Winner  = as.numeric(AwayGoals > HomeGoals))

unik_teams = sort(unique(c(no_ties_combined$Home, no_ties_combined$Away)))

results_combined = no_ties_combined %>%
  rename(home.team = Home, away.team = Away) %>%
  group_by(home.team, away.team) %>%
  summarise(home.win = sum(Home_Winner),
            away.win = sum(Opp_Winner),
            .groups = "drop") %>%
  mutate(home.team = factor(home.team, levels = unik_teams),
         away.team = factor(away.team, levels = unik_teams))

fit_all = BradleyTerry2::BTm(
  outcome = cbind(home.win, away.win),
  player1 = home.team,
  player2 = away.team,
  refcat = "Yenisey", 
  data = results_combined
)

```
```{r}
# extract team ability estimates from unified model
combined_lambda_hat = as.data.frame(BradleyTerry2::BTabilities(fit_all))
combined_lambda_hat = combined_lambda_hat %>%
  rownames_to_column("team")

# check
head(combined_lambda_hat %>% arrange(desc(ability)))

```

```{r}
uefa_playoff_teams= c(
  "Atalanta", "RB Leipzig", "Barcelona", "Manchester City",
  "Lyon", "Paris S-G", "Atlético Madrid", "Bayern Munich"
)

combined_lambda_hat = combined_lambda_hat %>%
  filter(team %in% uefa_playoff_teams)

combined_lambda_hat %>% arrange(desc(ability))
```


```{r}
# compute win probabilities
possible_matchups = quarters %>%
  dplyr::left_join(combined_lambda_hat %>% select(team, ability),
                   by = c("Hi" = "team")) %>%
  dplyr::rename(Hi_ability = ability) %>%
  dplyr::left_join(combined_lambda_hat %>% select(team, ability),
                   by = c("Lo" = "team")) %>%
  dplyr::rename(Lo_ability = ability) %>%
  dplyr::mutate(prob = exp(Hi_ability) / (exp(Hi_ability) + exp(Lo_ability)))

# helper function for 2-leg tie
simulate_two_leg = function(prob) {
  leg1 = rbinom(1, 1, prob)
  leg2 = rbinom(1, 1, prob)
  return(as.numeric((leg1 + leg2) >= 1))
}

possible_matchups
```

```{r}
n_sims = 10000

results = data.frame(
  SF1_Winner = rep(NA, times = n_sims),
  SF2_Winner = rep(NA, times = n_sims),
  Finals_Hi = rep(NA, times = n_sims),
  Finals_Lo = rep(NA, times = n_sims),
  Champion = rep(NA, times = n_sims)
)

for (r in 1:n_sims) {
  set.seed(321 + r)
  
  # QUARTER-FINALS
  qf_winners = rep(NA, nrow(possible_matchups))
  
  for (i in 1:nrow(possible_matchups)) {
    result = simulate_two_leg(possible_matchups$prob[i])
    if (result == 1) {
      qf_winners[i] = possible_matchups$Hi[i]
    } else {
      qf_winners[i] = possible_matchups$Lo[i]
    }
  }
  
  # SEMI-FINALS 
  semis = data.frame(
    Hi = c(qf_winners[1], qf_winners[3]),
    Lo = c(qf_winners[2], qf_winners[4])
  ) %>%
    dplyr::left_join(combined_lambda_hat %>% dplyr::select(team, ability),
                     by = c("Hi" = "team")) %>%
    dplyr::rename(Hi_ability = ability) %>%
    dplyr::left_join(combined_lambda_hat %>% dplyr::select(team, ability),
                     by = c("Lo" = "team")) %>%
    dplyr::rename(Lo_ability = ability) %>%
    dplyr::mutate(prob = exp(Hi_ability) / (exp(Hi_ability) + exp(Lo_ability)))
  
  sf_winners = rep(NA, nrow(semis))
  for (i in 1:nrow(semis)) {
    result = simulate_two_leg(semis$prob[i])
    if (result == 1) {
      sf_winners[i] = semis$Hi[i]
    } else {
      sf_winners[i] = semis$Lo[i]
    }
  }
  
  results[r, c("SF1_Winner", "SF2_Winner")] <- sf_winners
  
  # FINAL
  finals = data.frame(Team1 = sf_winners[1], Team2 = sf_winners[2]) %>%
    dplyr::left_join(
      combined_lambda_hat %>%
        dplyr::rename(Team1 = team, Team1_Ability = ability),
      by = "Team1"
    ) %>%
    dplyr::left_join(
      combined_lambda_hat %>%
        dplyr::rename(Team2 = team, Team2_Ability = ability),
      by = "Team2"
    ) %>%
    dplyr::mutate(
      Hi = ifelse(Team1_Ability > Team2_Ability, Team1, Team2),
      Lo = ifelse(Team1_Ability > Team2_Ability, Team2, Team1),
      Hi_ability = pmax(Team1_Ability, Team2_Ability),
      Lo_ability = pmin(Team1_Ability, Team2_Ability),
      prob = exp(Hi_ability) / (exp(Hi_ability) + exp(Lo_ability))
    ) %>%
    dplyr::select(Hi, Lo, prob)
  
  results[r, "Finals_Hi"] = finals$Hi[1]
  results[r, "Finals_Lo"] = finals$Lo[1]
  
  if (is.na(finals$prob[1])) finals$prob[1] = 0.5
  
  final_outcome = rbinom(1, 1, finals$prob[1])
  if (final_outcome == 1) {
    results[r, "Champion"] = finals$Hi[1]
  } else {
    results[r, "Champion"] = finals$Lo[1]
  }
}

# FINAL RESULTS 
champions = results %>%
  dplyr::count(Champion, sort = TRUE) %>%
  dplyr::mutate(Prob = n / n_sims)

champions

```


## Endnotes {#endnotes}

## References

```{js, echo=FALSE}
$(document).ready(function() {
  $('.footnotes ol').appendTo('#endnotes');
  $('.footnotes').remove();
});
```